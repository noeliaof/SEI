% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/std_index.R
\name{std_index}
\alias{std_index}
\title{Calculate standardised energy indices}
\usage{
std_index(
  x_new,
  x_ref = x_new,
  timescale = "days",
  dist = "empirical",
  return_fit = FALSE,
  moving_window = NULL,
  window_scale = NULL,
  agg_period = NULL,
  agg_scale = NULL,
  agg_fun = "sum",
  rescale = NULL,
  rescale_fun = "sum",
  index_type = "normal",
  ignore_na = FALSE
)
}
\arguments{
\item{x_new}{vector or time series to be converted to standardised indices.}

\item{x_ref}{vector or time series to be used as reference data when calculating the standardised indices.}

\item{dist}{string; distribution used to calculate the indices.}

\item{return_fit}{logical; return parameters and goodness-of-fit statistics for the distribution fit.}

\item{moving_window}{numeric; length of moving window on which to calculate the indices.}

\item{window_scale}{string; timescale of \code{moving_window}, default is "days".}

\item{agg_period}{numeric; the number of values to aggregate over.}

\item{agg_scale}{string; timescale of \code{agg_period}, default is "days".}

\item{agg_fun}{string; function used to aggregate the data over the aggregation period, default is "sum".}

\item{rescale}{string; the timescale that the time series should be rescaled to.}

\item{rescale_fun}{string; function used to rescale the data, default is "sum".}

\item{index_type}{string; the type of index: "normal" (default), "probability", or "bounded".}

\item{ignore_na}{logical; should NAs be ignored when rescaling the time series?}
}
\value{
Time series of standardised indices.
}
\description{
Inputs a time series of a chosen variable (e.g. residual load or
energy demand) and returns a time series of standardised indices. Different
types of indices can be calculated, on any timescale that is of interest.
}
\details{
Details about the std_index function will be added here
}
\examples{
data(data_supply)
# consider hourly German energy supply data in 2019
supply_de <- subset(data_supply, country == "Germany", select = c("date", "PWS"))
supply_de <- xts(supply_de$PWS, order.by = supply_de$date)
options(xts_check_TZ = FALSE)

# convert to hourly standardised indices
supply_de_std <- std_index(supply_de, timescale = "hours")
par(mfrow = c(1, 2))
hist(supply_de)
hist(supply_de_std)

# convert to daily or weekly standardised indices
supply_de_std <- std_index(supply_de, timescale = "hours", rescale = "days")

# convert to weekly standardised indices calculated on each day
supply_de_std <- std_index(supply_de, timescale = "hours", rescale = "days", agg_period = 1, agg_scale = "weeks")

# calculate standardised indices corresponding to December, based on the previous year
dec <- index(supply_de) >= "2019-01-12 UTC"
supply_de_std_dec <- std_index(x_new = supply_de[dec], x_ref = supply_de[!dec], timescale = "hours")

# calculate standardised indices using a 100 day moving window
supply_de_std_dec <- std_index(supply_de[dec], timescale = "hours", rescale = "days", moving_window = 100)

# suppose we are interested in the daily maximum rather than the daily total
supply_de_std <- std_index(supply_de, timescale = "hours", rescale = "days", rescale_fun = "max")
supply_de_std <- std_index(supply_de, timescale = "hours", rescale = "days", rescale_fun = "mean") # or average

# the default uses the empirical distribution, but this requires more data than
# parametric distributions, meaning it is not ideal when data is short, e.g. in weekly case
supply_de_std <- std_index(supply_de, timescale = "hours", rescale = "weeks") # warning
# instead, we can use a parametric distribution, e.g. a gamma distribution
supply_de_std <- std_index(supply_de, timescale = "hours", rescale = "weeks", dist = "gamma")
# we can check the fit by checking whether the indices resemble a standard normal distribution
hist(supply_de)
hist(supply_de_std)
# we can also look at the properties of the fit
supply_de_std <- std_index(supply_de, timescale = "hours", rescale = "weeks", dist = "gamma", return_fit = TRUE)

# alternatively, we can use kernel density estimation, which is a flexible compromise between the two
supply_de_std <- std_index(supply_de, timescale = "hours", rescale = "weeks", dist = "kde")

}
\references{
Allen, S. and N. Otero (2022):
`Standardised indices to monitor energy droughts',
\emph{EarthArXiv preprint} 4752.
\doi{10.31223/X51S92}

McKee, T. B., Doesken, N. J., & Kleist, J. (1993):
`The relationship of drought frequency and duration to time scales',
\emph{In Proceedings of the 8th Conference on Applied Climatology} 17, 179-183.
}
\author{
Sam Allen, Noelia Otero
}
